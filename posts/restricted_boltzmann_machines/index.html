<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.551">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Rushi Shah">
<meta name="dcterms.date" content="2024-05-18">

<title>Rushi’s Furnace - Bernoulli Restricted Boltzmann Machines</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="dark">
<script src="../../site_libs/quarto-contrib/glightbox/glightbox.min.js"></script>
<link href="../../site_libs/quarto-contrib/glightbox/glightbox.min.css" rel="stylesheet">
<link href="../../site_libs/quarto-contrib/glightbox/lightbox.css" rel="stylesheet">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<style type="text/css">
  h2, .h2 {
    border-bottom: none;
  }
</style>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Rushi’s Furnace</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/shahrushi2003"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com/RushiShah1729"> <i class="bi bi-twitter" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Bernoulli Restricted Boltzmann Machines</h1>
                      </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Rushi Shah </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">May 18, 2024</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<section id="what-is-generative-modelling" class="level1">
<h1>What is Generative Modelling?</h1>
<p>Generative modelling is the task of modelling the data distribution (which helps us generate new, similar, synthetic data points). There are multiple ways of dealing with this problem, with VAEs, diffusion models, and GANs being some of the popular ones. RBMs belong to this category of generative models, i.e.&nbsp;they are trained to model the data distribution <span class="math inline">\(p(x)\)</span>.</p>
<p>In this blog, we will extensively explore <strong>binary RBMs</strong> (i.e., RBMs that support only binary data). RBMs are not used today because training them on continuous data is difficult. Nevertheless, I find them to be a great introduction to energy-based models and concepts like Gibbs sampling and the Gibbs-Boltzmann distribution. Let’s start right away.</p>
</section>
<section id="the-concept-of-energy" class="level1">
<h1>The Concept of Energy</h1>
<p>Today, there exists a class of models called energy-based models, which provide a physics-oriented approach to model complex probability distributions based on the concept of “energy” of a system. This is made possible by defining an energy function <span class="math inline">\(E(\phi)\)</span> which calculates the energy of a given state <span class="math inline">\(\phi\)</span>. Utilising <span class="math inline">\(E(\phi)\)</span>, we can project the energy to a probabilistic space by using the Gibbs-Boltzmann distribution so that lower-energy states will have higher probability density and vice versa.</p>
<p><span class="math display">\[
p(\phi) = \frac{1}{Z} e^{-E(\phi)} ; \text{ where }
Z = \sum_{\phi} e^{-E(\phi)} \text{ is a normalising factor}
\]</span></p>
</section>
<section id="architecture" class="level1">
<h1>Architecture</h1>
<p>The components of binary RBMs can be separated into:</p>
<section id="state" class="level3">
<h3 class="anchored" data-anchor-id="state"><strong>State</strong></h3>
<ul>
<li><strong>Visible Nodes</strong> - These <strong>binary</strong> nodes are responsible for representing the data points in the input space. The use of these nodes will be clearer as we go deeper.</li>
<li><strong>Hidden Nodes</strong> - These are <strong>binary</strong> nodes responsible for creating an information bottleneck to enforce proper learning of underlying features. They represent data points in the latent space.</li>
</ul>
</section>
<section id="learnable-parameters" class="level3">
<h3 class="anchored" data-anchor-id="learnable-parameters"><strong>Learnable Parameters</strong></h3>
<ul>
<li><strong>Visible Biases</strong> - Each of the visible nodes has a bias parameter.</li>
<li><strong>Hidden Biases</strong> - Each of the hidden nodes has a bias parameter.</li>
<li><strong>Weights</strong> - Each visible node is connected to all hidden nodes through <strong>learnable</strong> weights. Basically, these weights will be a matrix of size (num_visible_nodes x num_hidden_nodes).</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="rbms.png" class="lightbox" data-gallery="quarto-lightbox-gallery-1"><img src="rbms.png" class="img-fluid quarto-figure quarto-figure-center figure-img"></a></p>
</figure>
</div>
</section>
</section>
<section id="notation" class="level1">
<h1>Notation</h1>
<p><span class="math inline">\(m\)</span> - number of visible nodes</p>
<p><span class="math inline">\(v_j\)</span> - <span class="math inline">\(j^{th}\)</span> visible node</p>
<p><span class="math inline">\(b_j\)</span> - bias of <span class="math inline">\(j^{th}\)</span> visible node</p>
<p><span class="math inline">\(\textbf{v}\)</span> - <span class="math inline">\([v_1, \dots v_m]\)</span></p>
<p><span class="math inline">\(n\)</span> - number of hidden nodes</p>
<p><span class="math inline">\(h_i\)</span> - <span class="math inline">\(i^{th}\)</span> hidden node</p>
<p><span class="math inline">\(c_i\)</span> - bias of <span class="math inline">\(i^{th}\)</span> hidden node</p>
<p><span class="math inline">\(\textbf{h}\)</span> - <span class="math inline">\([h_1, \dots h_n]\)</span></p>
<p><span class="math inline">\(w_{ij}\)</span> - weight connecting the <span class="math inline">\(j^{th}\)</span> visible node and the <span class="math inline">\(i^{th}\)</span> hidden node</p>
</section>
<section id="log-likelihood" class="level1">
<h1>Log-Likelihood</h1>
<p>Like every other generative model, RBMs are trained to learn a probability distribution to maximise the probability (or the log probability) of observing the observed training samples. In other words, assuming only one sample <span class="math inline">\(\textbf{v}\)</span> is given, we need to find theta such that the below function is maximised:</p>
<p><span class="math display">\[
\mathcal{L}(\theta|\textbf{v}) = ln(p(\textbf{v}|\theta))
\]</span></p>
<p>Here’s where the energy-based approach comes into play by providing a platform to define <span class="math inline">\(p(\textbf{v})\)</span>. The energy function for RBMs is defined as:</p>
<p><span class="math display">\[
E(\textbf{v}, \textbf{h}) = - \sum_{i} \sum_{j} w_{ij} v_j h_i - \sum_{j} b_j v_j - \sum_{i} c_i h_i
\]</span></p>
<p>Given the weights and biases, this energy function measures the compatibility between the visible and hidden units. Lower energy states correspond to more compatible or favourable configurations of visible and hidden units, while higher energy states correspond to less compatible configurations.</p>
<p>Since we now have the energy function, we can calculate the joint probability distribution as:</p>
<p><span class="math display">\[
p(\textbf{v}, \textbf{h}) = \frac{1}{Z} e^{-E(\textbf{v}, \textbf{h})}
\]</span></p>
<p>Where <span class="math inline">\(Z = \sum_{\textbf{v}, \textbf{h}} e^{-E(\textbf{v}, \textbf{h})}\)</span> the normalisation constant (also known as the partition function) ensures that the probabilities sum up to 1 over all possible configurations.</p>
<p>Defining the joint distribution unlocks the ability to define all underlying distributions. Through a series of calculations, we get the following expressions:</p>
<ol type="1">
<li><p>The joint distribution can now be used to define <span class="math inline">\(p(\textbf{v})\)</span>, the logarithm of which we need to minimise.</p>
<p><span class="math display">\[
p(\textbf{v}) = \sum_\textbf{h} p(\textbf{v}, \textbf{h}) = \frac{1}{Z} \sum_\textbf{h} e^{-E(\textbf{v}, \textbf{h})}
\]</span></p></li>
<li><p>Since <span class="math inline">\(\textbf{h}\)</span> is a binary variable, it can be represented with the help of a Bernoulli distribution as follows:</p>
<p><span class="math display">\[
p(H_i=1| \textbf{v})
= \sigma \Big(\sum_{j=1}^m w_{ij}v_j + c_i \Big)
\\
p(H_i=0| \textbf{v}) = 1 - p(H_i=1| \textbf{v})
\]</span></p></li>
<li><p>Since <span class="math inline">\(\textbf{v}\)</span> is also a binary variable, so we can do the same here as well:</p>
<p><span class="math display">\[
p(V_j=1| \textbf{h})
= \sigma \Big(\sum_{i=1}^n w_{ij}h_i + b_j \Big)
\\
p(V_j=0| \textbf{h}) = 1 - p(V_j=1| \textbf{h})
\]</span></p></li>
</ol>
</section>
<section id="gradient-calculation-logic" class="level1">
<h1>Gradient Calculation Logic</h1>
<p>Let’s go through a clear breakdown of the differentiation process. First, let’s simplify the loss function a bit:</p>
<p><span class="math display">\[\begin{equation*}
\begin{split}

\mathcal{L}(\theta|\textbf{v}) &amp;= ln(p(\textbf{v}|\theta)) = ln \Big(\frac{1}{Z} \sum_\textbf{h} e^{-E(\textbf{v}, \textbf{h})} \Big)
\\
&amp;= ln \Big(\sum_\textbf{h} e^{-E(\textbf{v}, \textbf{h})} \Big) - ln(Z)
\\
&amp;= ln \Big(\sum_\textbf{h} e^{-E(\textbf{v}, \textbf{h})} \Big) - ln \Big(\sum_{\textbf{v}, \textbf{h}} e^{-E(\textbf{v}, \textbf{h})} \Big)
\end{split}
\end{equation*}\]</span></p>
<p>Using the simple chain rule, we can calculate the gradient as follows:</p>
<p><span class="math display">\[\begin{equation*}
\begin{split}

\frac{\partial\mathcal{L}(\theta|\textbf{v})}{\partial \theta} &amp;= \frac{\partial}{\partial \theta} \Big( ln \Big(\sum_\textbf{h} e^{-E(\textbf{v},\textbf{h})} \Big) \Big) - \frac{\partial}{\partial \theta} \Big( ln \Big(\sum_{\textbf{v},\textbf{h}} e^{-E(\textbf{v},\textbf{h})} \Big) \Big)
\\
&amp;= - \frac{1}{\sum_\textbf{h} e^{-E(\textbf{v},\textbf{h})}} \sum_\textbf{h} e^{-E(\textbf{v},\textbf{h})} \frac{\partial E(\textbf{v},\textbf{h})}{\partial \theta} + \frac{1}{\sum_{\textbf{v},\textbf{h}} e^{-E(\textbf{v},\textbf{h})}} \sum_{\textbf{v},\textbf{h}} e^{-E(\textbf{\textbf{v},\textbf{h}})} \frac{\partial E(\textbf{v},\textbf{h})}{\partial \theta}
\end{split}
\end{equation*}\]</span></p>
<p>Now, we already know that,</p>
<p><span class="math display">\[
p(\textbf{v},\textbf{h}) = \frac{e^{-E(\textbf{v},\textbf{h})}}{\sum_{\textbf{v},\textbf{h}} e^{-E(\textbf{v},\textbf{h})}}
\]</span></p>
<p><span class="math display">\[
p(\textbf{h}|\textbf{v}) = \frac{p(\textbf{v},\textbf{h})}{p(\textbf{v})} = \frac{\frac{1}{Z} e^{-E(\textbf{v},\textbf{h})}}{\frac{1}{Z}  \sum_\textbf{h} e^{-E(\textbf{v},\textbf{h})}} = \frac{ e^{-E(\textbf{v},\textbf{h})}}{\sum_\textbf{h} e^{-E(\textbf{v},\textbf{h})}}
\]</span></p>
<p>Therefore, we can just put these in the gradient equation as follows:</p>
<p><span class="math display">\[\begin{equation*}
\begin{split}
\frac{\partial\mathcal{L}(\theta|\textbf{v})}{\partial \theta}

&amp;= -  \sum_\textbf{h} p(\textbf{h}|\textbf{v}) \frac{\partial E(\textbf{v},\textbf{h})}{\partial \theta}
+
\sum_{\textbf{v},\textbf{h}} p(\textbf{v},\textbf{h}) \frac{\partial E(\textbf{v},\textbf{h})}{\partial \theta}
\end{split}
\end{equation*}\]</span></p>
</section>
<section id="gradient-calculation-for-w_ij" class="level1">
<h1>Gradient Calculation for <span class="math inline">\(w_{ij}\)</span></h1>
<p>Now, we will look at the simplification of the gradient of loss w.r.t the weights (i.e.&nbsp;<span class="math inline">\(\theta = w_{ij}\)</span>).</p>
<section id="first-term-simplification" class="level2">
<h2 class="anchored" data-anchor-id="first-term-simplification">First Term Simplification</h2>
<p>Now, let’s calculate the first term of this gradient with <span class="math inline">\(\theta\)</span> as <span class="math inline">\(w_{ij}\)</span>:</p>
<p><span class="math display">\[
-\sum_\textbf{h} p( \textbf{h | v} ) \frac{\partial E(\textbf{v}, \textbf{h})}{\partial w_{ij}}
=
\sum_\textbf{h} p( \textbf{h | v} ) h_i v_j
\]</span></p>
<p>Here, some calculation tricks can be applied to simplify the right-side expression:</p>
<ol type="1">
<li>Since, all <span class="math inline">\(h_i\)</span>’s are independent, we can write <span class="math inline">\(p( \textbf{h | v} ) = \prod_{k=1}^n p(h_k|\textbf{v})\)</span>.</li>
<li><span class="math inline">\(\sum_h\)</span> can be rewritten as <span class="math inline">\(\sum_{h_i} \sum_{\textbf{h}_{\textbf{-i}}}\)</span>, where <span class="math inline">\(\textbf{h}_{\textbf{-i}}\)</span> represents a vector without the ith node.</li>
<li>Lastly, we can rewrite <span class="math inline">\(\prod_{k=1}^n p(h_k|\textbf{v}) = p(h_i| \textbf{v}) p(\textbf{h}_{\textbf{-i}} | \textbf{v})\)</span>.</li>
<li><span class="math inline">\(\sum_{\textbf{h}_{\textbf{-i}}}  p(\textbf{h}_{\textbf{-i}} | \textbf{v}) = 1\)</span>, obviously!</li>
</ol>
<p>Using the above tricks, the equation becomes:</p>
<p><span class="math display">\[\begin{equation*}
\begin{split}

-\sum_\textbf{h} p( \textbf{h | v} ) h_i v_j &amp;= \sum_{h_i} \sum_{\textbf{h}_{\textbf{-i}}} p(h_i| \textbf{v}) p(\textbf{h}_{\textbf{-i}} | \textbf{v}) h_i v_j
\\
&amp;= \sum_{h_i} p(h_i| \textbf{v}) h_i v_j \sum_{\textbf{h}_{\textbf{-i}}}  p(\textbf{h}_{\textbf{-i}} | \textbf{v})
\\
&amp;= \sum_{h_i} p(h_i| \textbf{v}) h_i v_j
\\
&amp;= p(H_i=0| \textbf{v}) (0) v_j + p(H_i=1| \textbf{v}) (1) v_j
\\
&amp;= p(H_i=1| \textbf{v}) v_j
\\
&amp;= \sigma \Big(\sum_{j=1}^m w_{ij}v_j + c_i \Big) v_j

\end{split}
\end{equation*}\]</span></p>
</section>
<section id="second-term-simplification" class="level2">
<h2 class="anchored" data-anchor-id="second-term-simplification">Second Term Simplification</h2>
<p><span class="math display">\[\begin{equation*}
\begin{split}

\sum_{\textbf{v},\textbf{h}} p(\textbf{v},\textbf{h}) \frac{\partial E(\textbf{v},\textbf{h})}{\partial w_{ij}}
&amp;= -\sum_\textbf{v} p(\textbf{v})
\sum_\textbf{h} p( \textbf{h | v} ) h_i v_j

\\

&amp;= -\sum_\textbf{v} p(\textbf{v})
p(H_i=1| \textbf{v}) v_j
\end{split}
\end{equation*}\]</span></p>
<p>Hence, the final gradient comes out to be:</p>
<p><span class="math display">\[
\frac{\partial\mathcal{L}(\theta|\textbf{v})}{\partial w_{ij}}
=
p(H_i=1| \textbf{v}) v_j
-
\sum_\textbf{v} p(\textbf{v})
p(H_i=1| \textbf{v}) v_j
\]</span></p>
</section>
</section>
<section id="final-gradient-calculation-formulas" class="level1">
<h1>Final Gradient Calculation Formulas</h1>
<p>Similar to what we did for <span class="math inline">\(w_{ij}\)</span>, we can calculate the gradient formulae for <span class="math inline">\(b_j\)</span> and <span class="math inline">\(c_i\)</span>. Hence, the final gradients formulae are:</p>
<p><span class="math display">\[
\frac{\partial\mathcal{L}(\theta|\textbf{v})}{\partial w_{ij}}
=
p(H_i=1| \textbf{v}) v_j
-
\sum_\textbf{v} p(\textbf{v})
p(H_i=1| \textbf{v}) v_j
\]</span></p>
<p><span class="math display">\[
\frac{\partial\mathcal{L}(\theta|\textbf{v})}{\partial b_{j}} = v_j - \sum_\textbf{v} p(\textbf{v}) v_j
\]</span></p>
<p><span class="math display">\[
\frac{\partial\mathcal{L}(\theta|\textbf{v})}{\partial b_{j}}
=
p(H_i=1| \textbf{v})
-
\sum_\textbf{v} p(\textbf{v})
p(H_i=1| \textbf{v})
\]</span></p>
</section>
<section id="approximating-the-gradients" class="level1">
<h1>Approximating the Gradients</h1>
<p>There’s a big problem with the above equations. Looping over <span class="math inline">\(\textbf{v}\)</span> is intractable. However, we can estimate this expectation with a series of approximations.</p>
<section id="approx.-1" class="level2">
<h2 class="anchored" data-anchor-id="approx.-1">Approx. 1</h2>
<p>Instead of looping over <span class="math inline">\(\textbf{v}\)</span>, we sample some samples from the distribution at hand [<span class="math inline">\(p(\textbf{v}, \textbf{h})\)</span> in this case] and calculate their mean. Practically, using just one sample works fine and fairly approximates the expectation.</p>
<p><span class="math display">\[
\hat{\textbf{v}} \sim p(\textbf{v}, \textbf{h})
\]</span></p>
<p><span class="math display">\[
\frac{\partial\mathcal{L}(\theta|\textbf{v})}{\partial w_{ij}}
=
p(H_i=1| \textbf{v}) v_j
-
p(H_i=1| \hat{\textbf{v}}) \hat{v}_j
\]</span></p>
<p><span class="math display">\[
\frac{\partial\mathcal{L}(\theta|\textbf{v})}{\partial b_{j}} = v_j - \hat{v}_j
\]</span></p>
<p><span class="math display">\[
\frac{\partial\mathcal{L}(\theta|\textbf{v})}{\partial b_{j}}
=
p(H_i=1| \textbf{v})
-
p(H_i=1| \hat{\textbf{v}})
\]</span></p>
</section>
<section id="approx.-2" class="level2">
<h2 class="anchored" data-anchor-id="approx.-2">Approx. 2</h2>
<p>Still, sampling <span class="math inline">\(\hat{\textbf{v}}\)</span> from <span class="math inline">\(p(\textbf{v}, \textbf{h})\)</span> is not possible because of the intractable <span class="math inline">\(Z\)</span> term encountered in the calculation of <span class="math inline">\(p(\textbf{v}, \textbf{h})\)</span>. However, the good news is that it is relatively (very!) easy to calculate <span class="math inline">\(p(\textbf{h} | \textbf{v})\)</span> and <span class="math inline">\(p(\textbf{v} | \textbf{h})\)</span> (remember the Bernoulli distributions we described a while ago?). Here’s where the Gibbs sampler comes in handy.</p>
<p>Basically, according to Mr.&nbsp;Gibbs, if you start with some <span class="math inline">\(\textbf{v}^0\)</span> AND sample <span class="math inline">\(\textbf{h}^1 \sim p(\textbf{h} | \textbf{v}^0)\)</span> and <span class="math inline">\(\textbf{v}^1 \sim p(\textbf{v} | \textbf{h}^1)\)</span> AND keep going till convergence (suppose we reach convergence after <span class="math inline">\(k\)</span> iterations), the samples <span class="math inline">\(\textbf{h}^k\)</span> and <span class="math inline">\(\textbf{v}^k\)</span> will look as if they were sampled from the intractable joint distribution <span class="math inline">\(p(\textbf{v}, \textbf{h})\)</span>.</p>
<p>We use Gibbs sampling because we can easily sample from <span class="math inline">\(p(\textbf{h}|\textbf{v})\)</span> and <span class="math inline">\(p(\textbf{v}|\textbf{h})\)</span> which are simple Bernoulli distributions.</p>
</section>
<section id="approx.-3" class="level2">
<h2 class="anchored" data-anchor-id="approx.-3">Approx. 3</h2>
<p>A small problem persists — performing Gibbs sampling until convergence is computationally expensive. However, the good news is that performing just one step of Gibbs sampling approximates the sampling process fairly enough for the gradient descent algorithm to work.</p>
</section>
</section>
<section id="final-algorithm" class="level1">
<h1>Final Algorithm</h1>
<p>All the above approximations combine to form the “Contrastive Divergence” algorithm for calculating the gradients of an RBM, which is seen clearly as follows:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="kcd_algo.png" class="lightbox" data-gallery="quarto-lightbox-gallery-2"><img src="kcd_algo.png" class="img-fluid quarto-figure quarto-figure-center figure-img"></a></p>
</figure>
</div>
<p>The above algorithm can be broken down as follows:</p>
<ol type="1">
<li>Initialise variables to store the gradient approximations. These will be used to update the parameters using gradient ascent.</li>
<li>Iterate over the training set and:
<ol type="a">
<li>Get a good approximation of a sample from the joint distribution by performing k iterations of Gibbs sampling.</li>
<li>Calculate the gradient of each parameter using the formulae we derived earlier.</li>
<li>Use the gradient storage variables to accumulate gradients for each parameter by adding the calculated gradient.</li>
<li>The final value of these gradient storage variables will be the final gradient approximation.</li>
</ol></li>
<li>(Not mentioned in the above photo) Using the gradient approximations outputted above, update the parameters using gradient ascent(we are maximising the <span class="math inline">\(\mathcal{L}(\theta|\textbf{v})\)</span>, hence ascent).</li>
</ol>
<p>With this, we have finally completed learning about binary RBMs. A lot of math, wasn’t it? I tried to make it as clear as possible, but if you have suggestions, feel free to contact me on shah.15@iitj.ac.in.</p>
</section>
<section id="references" class="level1">
<h1>References</h1>
<section id="rbms" class="level2">
<h2 class="anchored" data-anchor-id="rbms">RBMs</h2>
<ol type="1">
<li><a href="https://www.researchgate.net/publication/243463621_An_Introduction_to_Restricted_Boltzmann_Machines">An Introduction to RBMs by Fischer and Igel</a></li>
<li><a href="https://www.cs.toronto.edu/~hinton/absps/guideTR.pdf">Hinton’s “A Practical Guide to Training RBMs”</a></li>
<li><a href="https://medium.com/machine-learning-researcher/boltzmann-machine-c2ce76d94da5">An introductory Medium blog</a></li>
</ol>
</section>
<section id="gibbs" class="level2">
<h2 class="anchored" data-anchor-id="gibbs">Gibbs</h2>
<ol type="1">
<li><a href="https://mr-easy.github.io/2020-05-21-implementing-gibbs-sampling-in-python/">A short intro to Gibbs sampling</a></li>
<li><a href="https://jaketae.github.io/study/gibbs-sampling/">A detailed intro to Gibbs sampling</a></li>
</ol>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/shahrushi2003\.github\.io\/");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->
<script>var lightboxQuarto = GLightbox({"selector":".lightbox","openEffect":"zoom","loop":false,"descPosition":"bottom","closeEffect":"zoom"});
window.onload = () => {
  lightboxQuarto.on('slide_before_load', (data) => {
    const { slideIndex, slideNode, slideConfig, player, trigger } = data;
    const href = trigger.getAttribute('href');
    if (href !== null) {
      const imgEl = window.document.querySelector(`a[href="${href}"] img`);
      if (imgEl !== null) {
        const srcAttr = imgEl.getAttribute("src");
        if (srcAttr && srcAttr.startsWith("data:")) {
          slideConfig.href = srcAttr;
        }
      }
    } 
  });

  lightboxQuarto.on('slide_after_load', (data) => {
    const { slideIndex, slideNode, slideConfig, player, trigger } = data;
    if (window.Quarto?.typesetMath) {
      window.Quarto.typesetMath(slideNode);
    }
  });

};
          </script>




</body></html>